<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
        <data name="NeoFS">
            <value>NeoFS</value>
        </data>

        <data name="NeoFS is a distributed, decentralized object storage network. Used to its fullest potential, NeoFS can act as the host infrastructure for an entirely new class of truly decentralized applications.">
            <value>NeoFS 是一个去中心化的分布式对象存储网络。 一旦 NeoFS 发挥出其最大的潜力，将可以成为承载一系列完全去中心化应用的基础设施。</value>
        </data>

        <data name="The network also provides benefits for traditional web applications. It is designed to function as a drop-in replacement for expensive centralized data silos, granting developers full control over where and how their application data is stored and accessed. Stored data is always encrypted, and can be set to be decryptable by all or locked down with secure, granular access lists. NeoFS users always remain in complete control of their data.">
            <value>NeoFS 还可以服务于传统的 Web 应用程序。它可以替代昂贵的中心化数据存储孤岛，使开发者可以自主控制其应用程序数据的存储位置和访问方式。存储的数据始终保持加密，开发者可以将其设置完全解锁状态，也可以使用更为安全的分层化访问列表进行锁定。 NeoFS 用户始终拥有对自己数据的全部控制权。</value>
        </data>

        <data name="Malicious nodes that do not correctly store data are mitigated through zero-knowledge data validation techniques, and replication mechanisms provide a reliable service even in the event of a storage node failure. Even in a naturally chaotic decentralized environment, NeoFS provides a reliable service.">
            <value>在分布式环境中，NeoFS 也可以提供可靠的服务。NeoFS 使用的零知识数据验证技术可以缓解无法正确存储数据的恶意节点带来的负面影响。即使存储节点发生故障，复制机制也可以提供可靠的服务。</value>
        </data>

        <data name="An open market">
            <value>开放市场</value>
        </data>

        <data name="NeoFS operates on free market principles; anyone can join the network as a storage node or become elected to the inner ring to participate in network management and upkeep, earning rewards as a result.">
            <value>NeoFS 遵循自由市场的原则，任何人或机构都可以成为存储节点加入网络，更可以参选为内环节点参与网络治理并获得相应激励。</value>
        </data>

        <data name="The service is also uniquely customizable; those renting capacity from the network can select their desired geographic placement locations to minimize content delivery time to their users, define specific disk type requirements, or scale up to any desired level of redundancy.">
            <value>可定制性也是 NeoFS 服务的一大特性。租用存储资源的用户可以选择理想的物理存储位置，以最大程度地缩短交付数据所需的时间，或自定义特定的磁盘类型以及制定所需的冗余级别。</value>
        </data>

        <data name="It’s all native">
            <value>完全原生</value>
        </data>

        <data name="The network’s deep integration with the Neo blockchain introduces another revolutionary innovation. For the first time, smart contracts running on a public blockchain will be able to access and manipulate data stored in the decentralized cloud.">
            <value>NeoFS 与 Neo 区块链的深度集成带来了另一项革命性的创新：在公共区块链上运行的智能合约将首次可以访问和使用分布式云存储系统中的数据。</value>
        </data>

        <data name="Enabled through Neo’s native oracle, developers can tap into the NeoFS network at the code level, manipulating data from within NeoVM without the cost of persisting the data on-chain.">
            <value>通过 Neo 的内置预言机，开发者可以与 NeoFS 网络进行代码级别的互动，从 NeoVM 内处理数据，而无需在链上长期保存数据。</value>
        </data>

        <data name="NeoFS also makes the ideal host for application frontends, replacing the need for centralized web hosts. With the integrated CDN services, applications can even customize edge cache locations, ensuring the fastest possible delivery of data to their core users.">
            <value>NeoFS 可以成为程序前端的理想的载体，从而取代了程序对中心化 Web 主机的需求。借助集成在内的 CDN 服务，应用程序还可以自定义缓存位置，从而确保以最快的速度将数据交付给用户。</value>
        </data>

        <data name="With these pioneering tools, the new era of truly decentralized applications can be achieved with zero compromise on usability.">
            <value>借助这些创新，开发者无需对程序易用性做出任何妥协，就可以体验真正的去中心化应用程序时代。</value>
        </data>

</root>