<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
    <data name="dBFT 2.0">
        <value>dBFT 2.0</value>
    </data>

    <data name="When Satoshi Nakamoto introduced Bitcoin and the eponymous Nakamoto consensus mechanism to the world, the value of trustless and borderless transaction settlement was realized for the first time.">
        <value>当中本聪将比特币与其共识机制介绍给这个世界时，去信任化与无边界化的交易结算价值也第一次被我们所认知。</value>
    </data>

    <data name="Bitcoin and the many blockchains that followed typically achieve consensus with probabilistic finality. In other words, the transaction settlement is not necessarily guaranteed. In most cases, settlement becomes more difficult to overturn as the transaction becomes more deeply embedded in the blockchain.">
        <value>比特币以及随之诞生的许多区块链通常以概率终局性达成共识。换句话说，在区块链上不一定可以保证交易结算成功执行。而随着交易越来越深入地被嵌入到区块链条中，在大多数情况下结算也就变得更加难以被推翻。</value>
    </data>

    <data name="This is adequate for the needs of some applications, such as low-priority transfers or the simple storage of value. But for most user-facing or highly liquid applications, more reliable assurances are required regarding transaction settlement.">
        <value>这样的机制足以满足低优先级转账或简单价值存储等应用的需求，但是对于面向大量用户或流动性很高的应用程序，则要求在交易结算方面提供更可靠的保证。</value>
    </data>

    <data name="One block finality, maximum confidence">
        <value>单区块终局性，确定性最大化</value>
    </data>

    <data name="Since its inception, Neo has championed a BFT-powered, safety-first approach that has been rapidly gaining in popularity in the blockchain industry—and for good reason.">
        <value>从立项以来，Neo 一直引领着基于 BFT，安全优先的共识机制。拥有着独特优势，BFT 类共识机制近期在区块链行业内得到了迅速普及。</value>
    </data>

    <data name="Neo’s consensus mechanism, delegated Byzantine Fault Tolerance, represents a new evolution of the groundbreaking PBFT. Similar to its predecessor, dBFT requires a ⅔ majority agreement between validators called consensus nodes before new blocks can be committed to the blockchain.">
        <value>Neo 的共识机制 --dBFT（delegated Byzantine Fault Tolerance，委托拜占庭容错），是源于 PBFT 的突破式新发展。与 PBFT 相似，dBFT 需要在共识节点之间达成多数一致，然后才能将新区块添加到区块链中。</value>
    </data>

    <data name="This means the blockchain will never fork, and every transaction is permanently settled as soon as it is included in a confirmed block. In other words, Neo’s consensus mechanism immediately eliminates the possibility of transaction reversal. All applications based on Neo’s Layer 1 inherit this safety property.">
        <value>这意味着 Neo 区块链将永远不会分叉，每笔交易一旦包含在已确认的区块中，便会永久成立。换言之，Neo 的共识机制立即消除了交易逆转的可能性。所有基于 Neo 的 Layer 1 的应用都将继承这一属性。</value>
    </data>

    <data name="With Neo, users can always enjoy fast, low-cost transactions that are fully finalized within a single block.">
        <value>Neo 区块链上的用户始终可以享受快速、低成本的交易，这些交易都将在一个区块内全部完成。</value>
    </data>

    <data name="Democratic decentralization">
        <value>去中心化民主</value>
    </data>

    <data name="Like other Proof of Stake-based blockchains, Neo combines cryptographic tools and game theory to establish a robust and sustainable network. Governance voting by NEO stakeholders ensure all participants are economically aligned in a shared interest to safeguard the blockchain and its growing ecosystem. This democratic mechanism provides the Neo blockchain with all the tools required to fully decentralize control over the network.">
        <value>与其他基于 PoS 共识机制的区块链一样，Neo 结合了加密学与博弈论，从而建立一个强大而可持续的网络。NEO 持有者可通过投票获得相应激励，这将有助于所有治理参与者共同对 Neo 区块链的安全及可持续性发展负责。这种民主机制为 Neo 区块链提供了去中心化链上治理所需的所有工具。</value>
    </data>

</root>